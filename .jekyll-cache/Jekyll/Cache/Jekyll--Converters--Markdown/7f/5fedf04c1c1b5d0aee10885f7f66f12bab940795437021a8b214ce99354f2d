I"<ul>
  <li>什么是Promise</li>
  <li>传统异步解决方案</li>
  <li>设计Promise思维</li>
</ul>

<h2 id="什么是promise">什么是Promise</h2>
<blockquote>
  <p>Promise是一个容器，保存着一个异步操作的结果。Promise是一个对象，从它可以获取异步操作的消息。Promise提供了统一的api, 各种异步操作都可以用同样的方法进行处理。</p>
</blockquote>

<h2 id="传统异步解决方案">传统异步解决方案</h2>

<h3 id="一callback回调">一、callback回调</h3>

<p>通过参数闯入回调，未来调用回调时让函数的调用者判断发生了什么？</p>

<ul>
  <li>优点：简单、容易理解和部署</li>
  <li>缺点：不利于代码的阅读和维护，程序流程混乱，每个任务只能指定一个回调函数</li>
</ul>

<h3 id="二事件发布订阅模式">二、事件发布／订阅模式</h3>

<p>回调函数的事件化，任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p>

<ul>
  <li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>
  <li>缺点：整个程序变成了事件驱动型，运行流程会变得很不清晰</li>
</ul>

<h3 id="三deferred延迟函数">三、Deferred延迟函数</h3>

<p>通过deferred对象给异步操作进行状态绑定，deferred对象提供统一的api, 对各种异步操作状态进行操作（成功、失败、进行中）</p>

<ul>
  <li>优点：避免了层层嵌套的回调函数deferred对象提供统一的接口，控制异步操作更容易；</li>
  <li>缺点：状态不可逆，从待定状态切换到任何一个确定状态后，再次调用resole和reject对愿状态将不起任何作用；</li>
</ul>

<h2 id="设计promise思维">设计Promise思维</h2>

<blockquote>
  <p>思考： 用同步化的方法来书写异步代码</p>
</blockquote>

<p>异步操作的状态管理：成功\失败\进行中，每一个状态管理一个容器（3个），根据状态设计一个容器，container() add fire（依次找到处理函数），即成功之后的事情（找到对应的callback）、失败之后的事情（找到对应的callback）、进行中之后的事情（找到对应的callback）</p>

<ul>
  <li><code class="highlighter-rouge">成功</code> resolve()</li>
  <li><code class="highlighter-rouge">失败</code> reject()</li>
  <li><code class="highlighter-rouge">进行中</code></li>
</ul>

<p>容器设计<br /></p>
<ol>
  <li>多个处理函数(队列) deffered对象<br /></li>
  <li>fire（deferred.resolve、deferred.reject、、deferred.notify）、add（promise.done、promise.fail、promise.progress）</li>
</ol>

<p>知识普及：</p>
<blockquote>
  <p>闭包最大用处： 一个可以读取函数内部的变量，另一个就是让这些变量值保持在内存中；
思考：封闭作用域，保存作用域，作用域链条, 不污染全局变量、块级作用域</p>
</blockquote>
:ET