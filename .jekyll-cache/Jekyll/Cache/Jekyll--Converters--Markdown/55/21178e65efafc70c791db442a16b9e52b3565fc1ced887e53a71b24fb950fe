I"%r<ul>
  <li>什么是Promise</li>
  <li>传统异步解决方案</li>
  <li>设计Promise思维</li>
</ul>

<h2 id="什么是promise">什么是Promise</h2>
<blockquote>
  <p>Promise是一个容器，保存着一个异步操作的结果。Promise是一个对象，从它可以获取异步操作的消息。Promise提供了统一的api, 各种异步操作都可以用同样的方法进行处理。</p>
</blockquote>

<h2 id="传统异步解决方案">传统异步解决方案</h2>

<h3 id="一callback回调">一、callback回调</h3>

<p>通过参数闯入回调，未来调用回调时让函数的调用者判断发生了什么？</p>

<ul>
  <li>优点：简单、容易理解和部署</li>
  <li>缺点：不利于代码的阅读和维护，程序流程混乱，每个任务只能指定一个回调函数</li>
</ul>

<h3 id="二事件发布订阅模式">二、事件发布／订阅模式</h3>

<p>回调函数的事件化，任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p>

<ul>
  <li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>
  <li>缺点：整个程序变成了事件驱动型，运行流程会变得很不清晰</li>
</ul>

<h3 id="三deferred延迟函数">三、Deferred延迟函数</h3>

<p>通过deferred对象给异步操作进行状态绑定，deferred对象提供统一的api, 对各种异步操作状态进行操作（成功、失败、进行中）</p>

<ul>
  <li>优点：避免了层层嵌套的回调函数deferred对象提供统一的接口，控制异步操作更容易；</li>
  <li>缺点：状态不可逆，从待定状态切换到任何一个确定状态后，再次调用resole和reject对愿状态将不起任何作用；</li>
</ul>

<h2 id="设计promise思维">设计Promise思维</h2>

<blockquote>
  <p>思考： 用同步化的方法来书写异步代码</p>
</blockquote>

<p>异步操作的状态管理：成功\失败\进行中，每一个状态管理一个容器（3个），根据状态设计一个容器，container() add fire（依次找到处理函数），即成功之后的事情（找到对应的callback）、失败之后的事情（找到对应的callback）、进行中之后的事情（找到对应的callback）</p>

<ul>
  <li><code class="highlighter-rouge">成功</code> resolve()</li>
  <li><code class="highlighter-rouge">失败</code> reject()</li>
  <li><code class="highlighter-rouge">进行中</code></li>
</ul>

<p>容器设计<br /></p>
<ol>
  <li>多个处理函数(队列) deffered对象<br /></li>
  <li>fire（deferred.resolve、deferred.reject、、deferred.notify）、add（promise.done、promise.fail、promise.progress）</li>
</ol>

<p>知识普及：</p>
<blockquote>
  <p>闭包最大用处： 一个可以读取函数内部的变量，另一个就是让这些变量值保持在内存中；
思考：封闭作用域，保存作用域，作用域链条, 不污染全局变量、块级作用域</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
</pre></td><td class="rouge-code"><pre><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 成功的值</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 失败的值</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">pending</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 目前promise的状态为pending，还有resolved、rejected</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 可能new promise的时候存在异步操作，把成功和失败回调保存起来</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 把状态更改为成功</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span> 
    <span class="c1">// 只有pending状态才能转为成功状态</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">resolved</span><span class="dl">"</span><span class="p">;</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">rejected</span><span class="dl">"</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span><span class="p">;</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * 所有的promise都遵循这个规范，所有的promise可以通用
 * @param {*} promise2  then的返回值，返回新的promise
 * @param {*} x then中成功函数或失败函数的返回值
 * @param {*} resolve  promise2的resolve
 * @param {*} reject promise2的reject
 */</span>
<span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
  <span class="c1">// promise2和x是同一个对象，reject</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">promise2</span> <span class="o">===</span> <span class="nx">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Chaining cycle detected for promise</span><span class="dl">'</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">called</span><span class="p">;</span>
  <span class="c1">// then的返回值是promise，当x为对象或者函数，才可能是promise</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="o">!==</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)){</span>

    <span class="k">try</span><span class="p">{</span>
      <span class="kd">let</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span>
      <span class="c1">// x可以还是个promise，排除{then:{}}</span>
      <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">then</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">(</span><span class="nx">y</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
          <span class="c1">// y是返回promise后成功结果</span>
          <span class="c1">// 如果别人的promise可能既会调resolve也会调reject，那么就会出问题了，所以我们接下来要限制</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
          <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="c1">// 代码会一直递归，取到最后一层promis</span>
          <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
       
        <span class="p">},(</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
          <span class="c1">// 返回promise失败结果</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
          <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 如果then不是函数的话，那么则是普通对象，直接走resolve成功</span>
      <span class="p">}</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="c1">// x为一个常量，则是走resolve成功</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onFullfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="c1">// 那么我们new一个新的promise，并且把以下代码放到promise中</span>
  <span class="kd">let</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span><span class="p">){</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 这里的x， 上一层then执行返回的结果</span>
        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFullfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
        <span class="c1">// 提供一个resolvePromise函数处理promise2， then不管是成功回调、失败回调，返回值可能为promise／普通值／抛出错误值</span>
        <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">){</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span>  <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
        <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
      <span class="c1">// 把成功回调函数，存到改数组中，把参数传进去，不需要将来遍历onResolvedCallbacks时，再传参</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span><span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFullfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
            <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span>  <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
          <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">promise2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 简化的promise, 语法糖可以简化一些操作</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">defer</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">deferred</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="kd">let</span> <span class="nx">dfd</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="nx">dfd</span><span class="p">.</span><span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">dfd</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span><span class="nx">resolve</span><span class="p">;</span>
    <span class="nx">dfd</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span><span class="nx">reject</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">dfd</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 原生的Promise.resolve使用</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">catch</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promises</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">processData</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
       <span class="c1">// 所有结束时候</span>
      <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">processData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">),</span> <span class="nx">reject</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promises</span><span class="p">){</span>
  <span class="k">return</span>  <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 是否为模块引入，健壮性判断</span>
<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">module</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">undefined</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">undefined</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">define</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">define</span><span class="p">.</span><span class="nx">amd</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">define</span><span class="p">([],</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">Promise</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nb">Promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>
:ET